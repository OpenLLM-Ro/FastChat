{"question_id": 61, "answer_id": "YdL4XwENkLCLXMbH65rjKy", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["Iată un program simplu C++ care citește un fișier text linie cu linie și numără numărul de apariții ale unui anumit cuvânt din fișier:\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <șir>\n#include <sstream>\n\nint countWordOccurrences(const std::string& line, const std::string& word) {\n    std::istringstream iss(linie);\n    std::string currentWord;\n    număr int = 0;\n\n    while (iss >> currentWord) {\n        dacă (Cuvânt curent == cuvânt) {\n            numără++;\n        }\n    }\n\n    număr de retur;\n}\n\nint main() {\n    std::string fileName, wordToCount;\n    std::cout << \"Introduceți numele fișierului: \";\n    std::cin >> fileName;\n    std::cout << \"Introduceți cuvântul de numărat: \";\n    std::cin >> wordToCount;\n\n    std::ifstream inputFile(nume fișier);\n    dacă (!inputFile) {\n        std::cerr << \"Eroare la deschiderea fișierului: \" << fileName << std::endl;\n        întoarcere 1;\n    }\n\n    std::string line;\n    int totalCount = 0;\n    while (std::getline(inputFile, line)) {\n        totalCount += countWordOccurrences(line, wordToCount);\n    }\n\n    inputFile.close();\n\n    std::cout << \"Cuvântul \\\"\" << wordToCount << \"\\\" apare \" << totalCount << \" ori în fișier.\" << std::endl;\n\n    returnează 0;\n}\n```\n\nPentru a compila și a rula programul, salvați-l într-un fișier numit `word_counter.cpp` și utilizați următoarele comenzi:\n\n```sh\ng++ -o contor_cuvinte contor_cuvinte.cpp\n./număr_cuvinte\n```\n\nProgramul vă va solicita să introduceți numele fișierului și cuvântul pe care doriți să îl numărați. După aceea, va afișa numărul de apariții ale cuvântului specificat în fișier."]}], "tstamp": 1686545085.5954556}
{"question_id": 62, "answer_id": "4nk9zQkeRKvfjxEEqfyXmj", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["Iată o funcție Python care găsește cea mai lungă subsecvență comună a două șiruri de caractere de intrare folosind programarea dinamică:\n\n```python\ndef cea mai lungă_subsecvență_comună(s1, s2):\n    # Creați o matrice pentru a stoca lungimile subsecvențelor comune\n    matrice = [[0] * (len(s2) + 1) pentru _ în interval(len(s1) + 1)]\n\n    # Repetați prin șiruri și umpleți matricea\n    pentru i în interval (len(s1) - 1, -1, -1):\n        pentru j în interval(len(s2) - 1, -1, -1):\n            dacă s1[i] == s2[j]:\n                matrice[i][j] = 1 + matrice[i + 1][j + 1]\n            altceva:\n                matrice[i][j] = max(matrice[i + 1][j], matrice[i][j + 1])\n\n    # Reconstituiți cea mai lungă subsecvență comună din matrice\n    lcs = []\n    i, j = 0, 0\n    în timp ce i < len(s1) și j < len(s2):\n        dacă s1[i] == s2[j]:\n            lcs.append(s1[i])\n            i += 1\n            j += 1\n        elif matrice[i + 1][j] > matrice[i][j + 1]:\n            i += 1\n        altceva:\n            j += 1\n\n    returnează ''.join(lcs)\n\n# Exemplu de utilizare:\ns1 = „ABCDGH”\ns2 = „AEDFHR”\nprint(cea mai lungă_subsecvență_comună(s1, s2)) # Ieșire: „ADH”\n```\n\nAceastă funcție folosește programarea dinamică pentru a construi o matrice care stochează lungimile subsecvențelor comune pentru fiecare pereche de subșiruri. Apoi reconstruiește cea mai lungă subsecvență comună din matrice."]}], "tstamp": 1686544775.161658}
{"question_id": 63, "answer_id": "2MkXEfsoSuSC72BYGJuqhX", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["Pentru a implementa o expresie regulată în Python pentru a valida o adresă de e-mail, puteți utiliza modulul `re`. Iată un exemplu simplu:\n\n```python\nimport re\n\ndef validate_email(email):\n    model = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(model, e-mail))\n\n# Cazuri de testare\ne-mailuri = [\n    „test@example.com”,\n    „test@example.co.uk”,\n    \"test+123@example.com\",\n    „test@subdomeniu.example.com”,\n    „test@sub_domain.example.com”,\n    „test@sub-domeniu.example.com”,\n    \"test@exemplu\",\n    „test@.com”,\n    „test@.example.com”,\n    \"test@example..com\",\n    „test@.example..com”,\n    „test@example.com.”,\n    „.test@example.com”,\n]\n\npentru e-mail în e-mailuri:\n    print(f\"{email}: {validate_email(email)}\")\n```\n\nAceastă expresie regulată verifică următoarele condiții:\n\n1. Adresa de e-mail începe cu unul sau mai multe caractere alfanumerice, puncte, litere de subliniere, semne de procente, semne plus sau cratime.\n2. Urmat de simbolul „@”.\n3. Urmat de unul sau mai multe caractere alfanumerice, puncte sau cratime.\n4. Urmat de un punct.\n5. Se termină cu două sau mai multe caractere alfabetice.\n\nVă rugăm să rețineți că acesta este un exemplu simplu și este posibil să nu acopere toate carcasele marginale. Puteți modifica expresia regulată pentru a se potrivi mai bine cerințelor dumneavoastră specifice."]}], "tstamp": 1686544778.904383}
{"question_id": 64, "answer_id": "jPeywxk9g4LWyLPurjhsd2", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["Iată un program Python pentru a găsi al n-lea număr Fibonacci folosind programarea dinamică (cunoscută și sub numele de memorare):\n\n```python\ndef fibonacci(n, memo={}):\n    dacă n <= 0:\n        întoarce 0\n    elif n == 1:\n        întoarce 1\n    elif n nu este în memo:\n        memo[n] = Fibonacci (n - 1, memo) + Fibonacci (n - 2, memo)\n    returnează notă[n]\n\n# Testați funcția\nn = int(input(\"Introduceți valoarea lui n: \"))\nrezultat = Fibonacci(n)\nprint(f\"{n}al-lea număr Fibonacci este: {rezultat}\")\n```\n\nAcest program definește o funcție `fibonacci(n, memo={})` care calculează al n-lea număr Fibonacci folosind programarea dinamică. Dicționarul `memo` este folosit pentru a stoca rezultatele numerelor Fibonacci calculate anterior, ceea ce ajută la evitarea calculelor redundante și la îmbunătățirea eficienței programului."]}], "tstamp": 1686544763.1005273}
{"question_id": 65, "answer_id": "hD8NiB3PY5aoWg95mNjnj3", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["Iată o implementare Python a algoritmului de căutare binar pentru a găsi un anumit element într-o matrice sortată:\n\n```python\ndef binary_search(arr, target):\n    scăzut, ridicat = 0, len(arr) - 1\n\n    în timp ce scăzut <= ridicat:\n        mijloc = (scăzut + ridicat) // 2\n        mid_val = arr[mid]\n\n        if mid_val == target:\n            întoarce la mijloc\n        elif mid_val < target:\n            scăzut = mijloc + 1\n        altceva:\n            ridicat = mijloc - 1\n\n    întoarce -1\n\n# Exemplu de utilizare:\narr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\ntinta = 11\n\nrezultat = binary_search(arr, target)\ndacă rezultat != -1:\n    print(f\"Element {țintă} găsit la index {rezultat}\")\naltceva:\n    print(f\"Elementul {țintă} nu a fost găsit în matrice\")\n```\n\nAceastă funcție de căutare binară ia ca intrare o matrice sortată `arr` și o valoare țintă `target`. Inițializează doi pointeri, `low` și `high`, la primul și, respectiv, ultimul indici ai tabloului. Apoi, funcția actualizează iterativ pointerii și calculează indicele mijlociu `mid` până când este găsită valoarea țintă sau spațiul de căutare este epuizat. Dacă valoarea țintă este găsită, funcția returnează indexul valorii țintă; în caz contrar, returnează -1."]}], "tstamp": 1686544779.33291}
{"question_id": 66, "answer_id": "c4rAXsTfmioefx6icubuFB", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["Pentru a implementa o coadă folosind două stive în Python, puteți folosi următorul cod:\n\n```python\ncoada clasei:\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def queue(self, item):\n        self.stack1.append(articol)\n\n    def dequeue(self):\n        dacă nu self.stack2:\n            în timp ce self.stack1:\n                self.stack2.append(self.stack1.pop())\n        returnează self.stack2.pop()\n\n    def is_empty(self):\n        return not self.stack1 și nu self.stack2\n\n    dimensiune def (auto):\n        return len(self.stack1) + len(self.stack2)\n\n\n# Exemplu de utilizare:\ncoada = coada()\nqueue.enqueue(1)\nqueue.enqueue(2)\nqueue.enqueue(3)\n\nprint(queue.dequeue()) # Ieșire: 1\nprint(queue.dequeue()) # Ieșire: 2\n\nqueue.enqueue(4)\nqueue.enqueue(5)\n\nprint(queue.dequeue()) # Ieșire: 3\nprint(queue.dequeue()) # Ieșire: 4\nprint(queue.dequeue()) # Ieșire: 5\n```\n\nÎn această implementare, folosim două stive (`stiva1` și `stiva2`) pentru a simula comportamentul unei cozi. Când punem în coadă un articol, pur și simplu îl împingem pe „stiva1”. Când scoatem din coadă un articol, ieșim din `stack2`. Dacă `stiva2` este goală, mai întâi transferăm toate articolele din `stiva1` la `stiva2` (inversând ordinea lor) înainte de a ieși din `stiva2`. Acest lucru asigură că cel mai vechi articol din coadă este întotdeauna în partea de sus a „stivei2”."]}], "tstamp": 1686544798.8350058}
{"question_id": 67, "answer_id": "UQ3TFrzVqXtMTWpvhqtGym", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["Puteți implementa un program pentru a găsi elementele comune în două matrice, fără a utiliza structuri de date suplimentare, folosind bucle imbricate. Iată un exemplu în Python:\n\n```python\ndef find_common_elements(arr1, arr2):\n    elemente_comune = []\n\n    pentru eu in arr1:\n        pentru j în arr2:\n            dacă i == j:\n                common_elements.append(i)\n                pauză\n\n    returnează elemente_comune\n\n# Exemplu de utilizare:\narr1 = [1, 2, 3, 4, 5]\narr2 = [4, 5, 6, 7, 8]\n\nelemente_comune = find_common_elements(arr1, arr2)\nprint(\"Elemente comune:\", elemente_comune)\n```\n\nAcest program definește o funcție `find_common_elements` care ia ca intrare două matrice. Inițializează o listă goală `common_elements` pentru a stoca elementele comune găsite. Apoi, iterează prin fiecare element din prima matrice folosind o buclă, iar pentru fiecare element, iterează prin a doua matrice folosind o altă buclă. Dacă un element din primul tablou este găsit în al doilea tablou, acesta este adăugat la lista `common_elements` și bucla interioară este terminată folosind instrucțiunea `break`.\n\nÎn cele din urmă, funcția returnează lista `common_elements`. În exemplul de utilizare, programul găsește elementele comune între două tablouri `arr1` și `arr2` și tipărește rezultatul."]}], "tstamp": 1686544805.0822344}
{"question_id": 68, "answer_id": "eBGY6U9KCAsfuedcASSK7Q", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["Pentru a găsi valoarea lui f(2), înlocuiți x = 2 în funcția f(x) = 5x^3 - 2x + 3.\n\nf(2) = 5(2)^3 - 2(2) + 3\nf(2) = 5(8) - 4 + 3\nf(2) = 40 - 4 + 3\nf(2) = 36 + 3\nf(2) = 39\n\nDeci, valoarea lui f(2) este 39."]}], "tstamp": 1686544893.1474469}
{"question_id": 69, "answer_id": "KsgnWzbpEvoW7RmRwaLgMT", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["Pentru a rezolva pentru x în ecuația 3x + 10 = 5(x - 2), urmați acești pași:\n\n1. Distribuiți 5 în partea dreaptă a ecuației:\n3x + 10 = 5x - 10\n\n2. Mutați termenii x într-o parte scăzând 3x din ambele părți:\n10 = 2x - 10\n\n3. Mutați termenul constant în cealaltă parte adăugând 10 pe ambele părți:\n20 = 2x\n\n4. Împărțiți ambele părți la 2 pentru a izola x:\nx = 10\n\nDeci, soluția este x = 10."]}], "tstamp": 1686544795.032636}
{"question_id": 70, "answer_id": "BT82nWd8ZtXTzHrvhkg6eb", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["Pentru a afla lungimea segmentului de linie, putem folosi formula distanței:\n\nDistanța = √((x2 - x1)^2 + (y2 - y1)^2)\n\nAici, (x1, y1) = (2, -2) și (x2, y2) = (10, 4).\n\nIntroducând valorile, obținem:\n\nDistanța = √((10 - 2)^2 + (4 - (-2))^2)\nDistanța = √((8)^2 + (6)^2)\nDistanța = √(64 + 36)\nDistanța = √100\nDistanța = 10\n\nDeci, lungimea segmentului de linie este de 10 unități."]}], "tstamp": 1686544809.1491597}
